 === Linux commands ====
 `tree` - list contents of directories in a tree-like format (install with `sudo apt install tree`)
 `tree -L 1` - show only first level of directories
 `ps aux` - show all running processes (a - show processes of all users, u - show processes of current user, 
                                        x - show processes not attached to a terminal)
 `top` - display Linux processes (top -  display Linux processes in real time)
        `top -p <PID>` - display Linux process with specified PID
        `top -u <username>` - display Linux processes of specified user                                        
 `pstree` - display a tree diagram of running processes
 `pstree <PID>` - This will show the process tree starting from the specified PID
 `tmux` - terminal multiplexer, allows you to run multiple terminal sessions inside a single 
                                terminal window or remote terminal session (install with `sudo apt install tmux`)
  `tmux ls` - list all tmux sessions
  `tmux attach -t <session_name>` - attach to tmux session with specified name
  `tmux kill-session -t <session_name>` - kill tmux session with specified name
  `tmux new -s <session_name>` - create new tmux session with specified name
  `tmux rename-session -t <old_session_name> <new_session_name>` - rename tmux session
  `tmux detach` - detach from tmux session (keep session running in background) or simply `CTRL-B d`
  `tmux windows` - list all windows in tmux session
  `tmux new-window` - create new window in tmux session, or simply `CTRL-B c`
  `Ctrl-b %` - split tmux window vertically
  `Ctrl-b "` - split tmux window horizontally
  `Ctrl-b <arrow key>` - switch between tmux windows
  `Ctrl-b : list-command` - list all tmux commands
  `Ctrl-b : [` - enter copy mode (use arrow keys to navigate, press `v` to select text, press `y` to copy selected text)

 `kill <PID>` - terminate process with specified PID
 `killal` - send a signal to all processes running any of the specified commands
 `killall chrome` -  terminate all running instances of the Google Chrome browser on your Linux system
 `killall -9 process_name` - This signal is commonly known as a "forceful" or "hard" kill signal because it immediately 
                             terminates the processes without allowing them to perform any cleanup tasks or graceful shutdown procedures.
 `miniterm` - simple terminal program for the serial port (installed as part of pyserial package `sudo apt install python3-serial`)
              can be used to send commands to the serial port (e.g. send to Arduino [Arduino is used as a motor controller])
              `miniterm /dev/ttyACM0 115200` - open serial port with baudrate 115200

 `wget` - command-line utility for downloading files from the web (install with `sudo apt install wget`)
          `wget -O <filename> <url>` - download file from url and save it as filename
          or simply `wget <url>` - download file from url and save it with original name
  
 `tee` - read from standard input and write to standard output and files (install with `sudo apt install tee`)
         `echo "Hello World" | tee hello.txt` - write "Hello World" to hello.txt and print it to stdout
         `echo "Hello World" | tee -a hello.txt` - append "Hello World" to hello.txt and print it to stdout

  --- Journal is a system service for collecting and storing log data (it is a part of systemd) ---
  `journalctl` - query the systemd journal (systemd is a system and service manager for Linux operating systems, that is 
                 responsible for starting and stopping services and daemons, mounting and unmounting file systems, 
                 maintaining the system clock, and other system management tasks)
  `journalctl -fe` - show the latest journal entries and continuously print new entries as they are appended to the journal
  `journalctl -f` - show only new entries as they are appended to the journal
  `journalctl -b` - show messages from the current boot
  `journalctl -u <service_name>` - show logs of service (to get list of services use `systemctl list-units --type=service`)
                                 E.g. `journalctl -b -u docker.service` - show logs of docker service from the current boot
              

  --- Systemctl is a systemd utility that is responsible for Controlling the systemd system and service manager ---
                Service manager is a background process that manages the life cycle of services in the system
  `systemctl list-units`- lists all currently loaded systemd units, which includes both active and inactive units
  `systemctl list-units --type=service` - show list of services that are currently loaded
  `systemctl list-unit-files` - lists all available systemd unit files on your system. Unit files define services, targets, 
                                sockets, timers, and other systemd units that can be activated.
    units are represented by unit files, which are stored in the /usr/lib/systemd/system/ and /etc/systemd/system/ directories.
    they are merely configuration files that describe the unit and define its behavior 
    (e.g. /etc/systemd/system/docker.service, .socket, .target, etc)                              
  `systemctl status <service_name>` - show status of service
  `systemctl enable <service_name>` - enable service to start automatically at boot
  `systemctl disable <service_name>` - disable service to start automatically at boot
  `systemctl start <service_name>` - start service
  `systemctl stop <service_name>` - stop service
  `systemctl get-default` - show default target (default target is a special systemd unit that is loaded by default when 
                            the system boots. It is similar to runlevel in the init system)
                            Target is a special kind of unit that does not do anything itself but instead acts as a
                            collection of other units. It is used to group units together and to simplify the boot process.
  `systemctl set-default <target_name>` - set default target (e.g. `systemctl set-default multi-user.target` 
                                                              - set default target to multi-user.target)
  `systemctl list-units --type=target` - show list of targets (shown only active targets)
  `systemctl list-dependencies <target_name>` - show list of units that are dependencies of target 
                                                (e.g. `systemctl list-dependencies multi-user.target`)

  --- RPi ---
  `vcgencmd` is a command-line utility used on Raspberry Pi devices that runs the VideoCore GPU on the Raspberry Pi.
             VideoCore is a low-power mobile multimedia processor originally developed for the Raspberry Pi project.
             It allows you to query various hardware-related information, such as firmware revision, temperature.
  `vcgencmd commands` - show all available commands
  `vcgencmd measure_temp` - show CPU temperature
  `vcgencmd get_throttled` - show under-voltage and over-temperature flags (if 0x0 - everything is ok, if 0x50000 - under-voltage, 
                             if 0x50005 - under-voltage and over-temperature,
                             if 0x50001 - under-voltage and currently throttled, if 0x50006 - under-voltage, over-temperature and currently throttled)
                             (throttled means that CPU frequency is reduced because of under-voltage or over-temperature)         

  To set RPi to boot to console (without GUI)
  `sudo systemctl set-default multi-user.target` - set default target to multi-user.target (multi-user.target is a target that 
                                                   provides a console login and is the default target for non-graphical Raspberry Pi OS images)

  --- Networking
   -- Scan hosts in the network --
    `nmap -sn 192.168.5.0/24` - performs a ping scan to find live hosts in the range 192.168.5.0
                              -sn: Ping Scan - disable port scan  
    `nmap -p 22 192.168.5.0/24` - scan for hosts with port 22 (SSH) open  

   -- systemd-networkd is part of the systemd init system and offers a minimalistic approach to network configuration 
      and management, often used in server environments
    - `/etc/systemd/network/` - network configuration files are stored in this directory
    - `systemctl status systemd-networkd.service` - show status of systemd-networkd service

   -- NetworkManager is a daemon that sits on top of libudev and other Linux kernel interfaces and provides a 
      high-level interface for the configuration of the network interfaces
    - `/etc/NetworkManager/` - NetworkManager configuration files are stored in this directory
    - `/etc/NetworkManager/system-connections/`: This directory holds configuration files for network connections, 
      each represented as a separate file. These files are usually named after the connection's name.
    - `systemctl status NetworkManager.service` - show status of NetworkManager service
    - `mcli` is a command-line tool for controlling NetworkManager and reporting network status.
    - `nmcli device show` - show all network interfaces
    - `nmcli connection show` - show all connections
    - `nmcli connection up <connection_name>` - activate connection
    - `nmcli connection down <connection_name>` - deactivate connection
    - `nmtui` - text user interface for NetworkManager
   
   -- Netplan is a network configuration utility for Linux. It is used to configure the network interfaces 
      through YAML files. From YAML description Netplan will generate all the necessary configuration for your 
      chosen renderer tool (NetworkManager or networkd).
    - `/etc/netplan/` - config files (.yaml) are located in this directory
    - `netplan apply` - apply changes

=== ROS2 commands ===
  --- TF2 commands ---
  Generate pdf file with TF transform tree
  `ros2 run tf2_tools view_frames.py`

  `tf_echo` reports the transform between any two frames broadcast over ROS
  `ros2 run tf2_ros tf2_echo <parent frame> <child frame>`

  --- ROS2 topic commands ---
  `ros2 topic echo /wheel/odometry`
  `ros2 topic echo /my_topic --no-arr` --no-addr - don't print array fields of messages

  Retrieve information about a topic
  `ros2 topic info /tf --verbose`

  Name remapping
  `ros2 run rplidar_ros rplidar_node --ros-args -r __ns:=scanner2`
  `-r __ns:=scanner2` this changes the namespace of the node rplidar_node to 'scanner2' (/scanner/rplidar_node) 
  `-r __node:=<new node name>` this renames the node to 'new_node_name'.
  Namespace allows you to run multiple instances of the same node with separate parameter spaces.

  --- ROS2 params ---
  To see the parameters belonging to your nodes
  `ros2 param list`

  To display the type and current value of a parameter
  `ros2 param get <node_name> <parameter_name>`

  This command will set the value of a particular parameter on a particular node. 
  `ros2 param set <node_name> <parameter_name> <parameter_value>`
  `ros2 param set /my_node my_string off`

  To save your current configuration of node’s parameters, enter the command:
  `ros2 param dump <node_name>`

  --- ROS2 control commands ---
  `ros2 control list_controllers` - list loaded controllers, their type and status
  `ros2 control list_hardware_components` - list available hardware components
  `ros2 control list_hardware_interfaces` - list available command and state interfaces

  --- Package commands ---
  Get the installation location of package
  `ros2 pkg prefix <package name>`

  --- RQT commands ---
  RQT is a Qt-based framework for GUI development for ROS. 
  Qt is a cross-platform application framework that is widely used for developing application software with a 
  graphical user interface (GUI)
  rqt is a meta package that depends on all available e.g rqt_graph, rqt_image_view, etc
  `ros2 run rqt_graph rqt_graph` - show graph of nodes and topics (rqt_graph is a part of rqt_graph package)
                                   rqt_graph is a dynamic GUI plugin for visualizing the ROS computation graph.
                                   (dynamic plugin is a plugin that can be loaded and unloaded at runtime)
  `ros2 run rqt_image_view rqt_image_view` - show image from camera (rqt_image_view is a part of rqt_image_view package)


=== Gazebo ===
--- Add path to robot model (this line maybe added to ~/.bashrc or docker images entrypoint
--- [ros_entrypoint.sh])
export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/ros_ws/src/bigfootbot_description/models/


==== Docker commmands ===

--- Buid image
docker build -f Dockerfile.aarch64.humble.nav2.realsense -t humble_realsense:latest --build-arg BASE_IMAGE="nvidia_x86_64_humble_nv2" ..

--- Run new terminal in the running container
docker exec -it <container-name/ID> bash

--- Run docker containers with GUI ---
xhost +local:root 
OR
xhost +

docker run -it --rm --privileged --network host --runtime=nvidia --gpus all --env="DISPLAY" --env="QT_X11_NO_MITSHM=1" --volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" aarch64_humble_realsense:latest
(--rm Automatically remove the container when it exits)
(--gpus # flag when you start a container to access GPU resources. Specify how many GPUs to use (all - use all GPUs))
(--privileged flag gives all capabilities to the container, and it also lifts all the limitations enforced by the device cgroup controller. 
(--volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" read-write mode (i.e. the container can write as well as read files on the host))
In other words, the container can then do almost everything that the host can do)

To capture docker build logs to a file
 `docker build -f Dockerfile.bfb_camera_d435i -t bfb_camera_d435i:latest ../.. 2>&1 | tee build.log`
 2>&1 redirects stderr to stdout, and then | tee build.log pipes stdout to tee, which writes it to build.log and also displays it on the screen.

--- end of block 'run docker containers wit GUI ---

--- Create and start containers
docker compose -f docker-compose_lenovo.yml up # Version2

docker-compose up
docker-compose up --build (Build images before starting containers.)

--- Start the stopped containers, can't create new ones
docker-compose start

--- Stop and remove containers, networks, images, and volumes
docker-compose down

--- List containers
docker-compose ps
docker ps -a

--- Inspect (containers, networks, images, volumes)
`docker inspect <container name>` - show container info (IP address, etc)
   docker container inspect 2186a1927d6a | grep compose 
`docker inspect <network name>` - show network info
`docker inspect <image name>` - show image info
`docker inspect <volume name>` - show volume info

=== END OF BLOCK 'docker commands' ===



=== WSL2 ===
-- Attach USB devices
--- From an administrator command prompt on Windows, run this command. 
--- It will list all the USB devices connected to Windows.
usbipd wsl list

--- Select the bus ID of the device you’d like to attach to WSL and run this command. 
--- You’ll be prompted by WSL for a password to run a sudo command.
usbipd wsl attach --busid <busid>


=== Git commands ===
`git remote -v` - show remote repositories
`git branch -v` - show local branches
`git merge <branch_name>` - merge branch_name into current branch (commits history will be saved)
                            simply put "Please add my changes to the branch I'm currently on."
`git rebase <branch_name>` - rebase current branch on top of branch_name (commits history will be rewritten by new commits from branch_name)
                             simply put "Please add my changes on top of what everybody else has already done."

  Note. Use rebase only for local branches. Do not rebase branches others are working on. Rebase changes 
  the commit history, and others will not know about it.

For example if you have a branch called new-feature and you want to merge it into main, you would do the following:
`git checkout main`
`git merge new-feature` // merge new-feature into main
// or
`git checkout new-feature`
`git rebase main` // rebase new-feature on top of main (commits history of new-feature will be rewritten by new commits from main)

-- If you're merging a new feature into the main branch, 
you first want to switch to the main branch and then merge into it:

`git checkout new-branch` (e.g. new-feature)
# ...develop some code...

`git add –A`
`git commit –m "Some commit message"`
`git checkout main`
Switched to branch 'main'
`git merge new-branch` (e.g. new-feature)